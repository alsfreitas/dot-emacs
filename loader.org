#+TITLE: Emacs configuration file
#+AUTHOR: Anderson Freitas
#+BABEL: :cache yes
#+LATEX_HEADER: \usepackage{parskip}
#+LATEX_HEADER: \usepackage{inconsolata}
#+LATEX_HEADER: \usepackage[utf8]{inputenc}
#+PROPERTY: header-args :tangle yes

* About

  This is an Emacs configuration file written in [[http://orgmode.org][Org mode]]. It is an attempt
  to keep my =~/.emacs.d= tidy, but still be able to keep it all in one
  file. I aim to briefly explain all my configurations as I go along!

  I would not recommend using this configuration /as-is/, because it
  probably contains a lot you don't really need. I do, however, hope people
  find some golden nuggets that they can smuggle into their own configs.

  If you really do want to try this config out, this is how I'd go about it:

  Clone the repo.
  #+BEGIN_SRC sh :tangle no
  git clone https://github.com/alsfreitas/dot-emacs
  #+END_SRC

  Backup your old =~/.emacs.d= (if necessary).
  #+BEGIN_SRC sh :tangle no
  mv ~/.emacs.d ~/.emacs.d-bak
  #+END_SRC

  Backup your old =~/.emacs=-file (if necessary).
  #+BEGIN_SRC sh :tangle no
  mv ~/.emacs ~/.emacs-bak
  #+END_SRC

  And finally
  #+BEGIN_SRC sh :tangle no
  mv dot-emacs ~/.emacs.d
  #+END_SRC

  On first run it should install a bunch of packages (this might take a
  while), and you might have to restart your Emacs the first time. If you
  experience bugs, please let me know!

* Configurations
** Meta

   All changes to the configuration should be done in =init.org=, *not* in
   =init.el=. Emacs can't load =.org=-files directly, but =org-mode= provides
   functions to extract the code blocks and write them to a file. There are
   multiple ways of handling this; like suggested by [[http://emacs.stackexchange.com/questions/3143/can-i-use-org-mode-to-structure-my-emacs-or-other-el-configuration-file][this StackOverflow post]],
   one could just use =org-babel-load-file=, but I had problems with
   byte-compilation.

   When this configuration is loaded for the first time, the ~init.el~ is the
   file that is loaded. It looks like this:

   #+BEGIN_SRC emacs-lisp :tangle no
   (package-initialize)

   (if (file-exists-p (concat user-emacs-directory "loader.el"))
     (load-file (concat user-emacs-directory "loader.el"))
     (progn
       ;; We can't tangle without org!
       (require 'org)
       ;; Open the configuration
       (find-file (concat user-emacs-directory "loader.org"))
       ;; tangle it
       (org-babel-tangle)
       ;; finally byte-compile it
       (byte-compile-file (concat user-emacs-directory "loader.el"))
       ;; then loads the tangled file
       (load-file (concat user-emacs-directory "loader.el"))))
   #+END_SRC

   The =loader.el= should mirror the source blocks in the =loader.org=. 
   We can use =C-c C-v t= to run =org-babel-tangle=, which extracts the
   code blocks from the current file into a source-specific file (in 
   this case a =.el=-file).

   To avoid doing this each time a change is made we can add a function to
   the =after-save-hook= ensuring to always tangle and byte-compile the
   =org=-document after changes.

   #+BEGIN_SRC emacs-lisp
   (defun tangle-init ()
     "If the current buffer is 'init.org' the code-blocks are
   tangled, and the tangled file is compiled."
     (when (equal (buffer-file-name)
                  (expand-file-name (concat user-emacs-directory "loader.org")))
       ;; Avoid running hooks when tangling.
       (let ((prog-mode-hook nil))
         (org-babel-tangle)
         (byte-compile-file (concat user-emacs-directory "loader.el")))))

   (add-hook 'after-save-hook 'tangle-init)
   #+END_SRC

   I'd like to keep a few settings private, so we load a =private.el= if it
   exists after the init-file has loaded.

   #+BEGIN_SRC emacs-lisp
   (add-hook
    'after-init-hook
    (lambda ()
      (let ((private-file (concat user-emacs-directory "private.el")))
        (when (file-exists-p private-file)
          (load-file private-file)))))
   #+END_SRC

** Sane defaults

   These are what /I/ consider to be saner defaults.

   Turn off garbage collection during startup. Turn back on when startup is
   complete, but set new threshold to 100MB.

#+BEGIN_SRC 
   (set-threshold most-positive-fixnum)
   (add-hook 'afterter-init-hook (lambda () (setq gc-cons-threshold 104857600)))
#+END_SRC

   Auto refresh buffers.
  
#+BEGIN_SRC 
   (global-auto-revert-mode 1)
#+END_SRC

   We can set variables to whatever value we'd like using =setq=.

   #+BEGIN_SRC emacs-lisp
   (setq auto-revert-interval 1            ; Refresh buffers fast
         custom-file (make-temp-file "")   ; Discard customization's
         echo-keystrokes 0.1               ; Show keystrokes asap
         inhibit-startup-message t         ; No splash screen please
         initial-scratch-message nil       ; Clean scratch buffer
         recentf-max-saved-items 100       ; Show more recent files
         ring-bell-function 'ignore        ; Quiet
         sentence-end-double-space nil     ; No double space
         load-prefer-newer t)              ; Avoid using outdated compiled files
         
   #+END_SRC

   Some variables are buffer-local, so changing them using =setq= will only
   change them in a single buffer. Using =setq-default= we change the
   buffer-local variable's default value.

   #+BEGIN_SRC emacs-lisp
   (setq-default fill-column 80                    ; Maximum line width
                 truncate-lines t                  ; Don't fold lines
                 indent-tabs-mode nil              ; Use spaces instead of tabs
                 next-line-add-newlines nil        ; Self-described
                 require-final-newline nil         ; Self-described
                 split-width-threshold 100         ; Split verticly by default
                 auto-fill-function 'do-auto-fill) ; Auto-fill-mode everywhere
   #+END_SRC

   Enables important commands that are disabled by default.

   #+BEGIN_SRC emacs-lisp
   (put 'upcase-region 'disabled nil)
   (put 'downcase-region 'disabled nil)
   #+END_SRC

   The =load-path= specifies where Emacs should look for =.el=-files (or Emacs
   lisp files). I have a directory called =site-lisp= where I keep all
   extensions that have been installed manually (these are mostly my own
   projects).

   #+BEGIN_SRC emacs-lisp
   (let ((default-directory (concat user-emacs-directory "site-lisp/")))
     (when (file-exists-p default-directory)
       (setq load-path
             (append
              (let ((load-path (copy-sequence load-path)))
                (normal-top-level-add-subdirs-to-load-path)) load-path))))
   #+END_SRC

   Answering /yes/ and /no/ to each question from Emacs can be tedious, a
   single /y/ or /n/ will suffice.

   #+BEGIN_SRC emacs-lisp
   (fset 'yes-or-no-p 'y-or-n-p)
   #+END_SRC

   Avoid startup message from showing at the minibuffer.

   #+BEGIN_SRC emacs-lisp
   (fset 'display-startup-echo-area-message 'ignore)
   #+END_SRC

   To avoid file system clutter we put all auto saved files in a single
   directory.

   #+BEGIN_SRC emacs-lisp
   (defvar emacs-autosave-directory
     (concat user-emacs-directory "autosaves/")
     "This variable dictates where to put auto saves. It is set to a
     directory called autosaves located wherever your .emacs.d/ is
     located.")

   ;; Sets all files to be backed up and auto saved in a single directory.
   (setq backup-directory-alist
         `((".*" . ,emacs-autosave-directory))
         auto-save-file-name-transforms
         `((".*" ,emacs-autosave-directory t)))
   #+END_SRC

   Set =utf-8= everywhere.

   #+BEGIN_SRC emacs-lisp
   (setq locale-coding-system 'utf-8)
   (set-terminal-coding-system 'utf-8)
   (set-keyboard-coding-system 'utf-8)
   (set-selection-coding-system 'utf-8)
   (prefer-coding-system 'utf-8)
   (set-language-environment "UTF-8")
   #+END_SRC

   By default the =narrow-to-region= command is disabled and issues a warning,
   because it might confuse new users. I find it useful sometimes, and don't
   want to be warned.

   #+BEGIN_SRC emacs-lisp
   (put 'narrow-to-region 'disabled nil)
   #+END_SRC

** Key bindings

   Kill the current buffer.

   #+BEGIN_SRC emacs-lisp
   (global-set-key (kbd "C-x k") 'kill-this-buffer)
   #+END_SRC

** Modes

   There are some modes that are enabled by default that I don't find
   particularly useful. We create a list of these modes, and disable all of
   these.

   #+BEGIN_SRC emacs-lisp
   (dolist (mode
            '(tool-bar-mode                ; No toolbars, more room for text
              scroll-bar-mode              ; No scroll bars either
              blink-cursor-mode            ; The blinking cursor gets old
              menu-bar-mode))              ; Set of menus at the top of each frame
     (funcall mode 0))
   #+END_SRC

   Let's apply the same technique for enabling modes that are disabled by default.
                                        
   #+BEGIN_SRC emacs-lisp
   (dolist (mode
            '(abbrev-mode                  ; E.g. sopl -> System.out.println
              column-number-mode           ; Show column number in mode line
              delete-selection-mode        ; Replace selected text
              dirtrack-mode                ; directory tracking in *shell*
              global-prettify-symbols-mode ; Greek letters should look greek
              golden-ratio-mode            ; Automatic resizing of windows
              projectile-global-mode       ; Manage and navigate projects
              recentf-mode                 ; Recently opened files
              show-paren-mode              ; Highlight matching parentheses
              winner-mode))                ; It allows you to “undo” (and “redo”)
                                           ; changes in the window configuration
     (funcall mode 1))

   (when (version< emacs-version "24.4")
     (eval-after-load 'auto-compile
       (auto-compile-on-save-mode)))  ; compile .el files on save
   #+END_SRC

** Mac OS X

   I run this configuration mostly on Mac OS X, so we need a couple of settings
   to make things work smoothly. In the package section =exec-path-from-shell=
   is included (only if you're running OS X), this is to include
   environment-variables from the shell. It makes using Emacs along with
   external processes a lot simpler. I also prefer using the =Command=-key as
   the =Meta=-key.

   #+BEGIN_SRC emacs-lisp
   (when (memq window-system '(ns darwin))
     (setq ns-pop-up-frames nil
           mac-option-modifier nil
           mac-command-modifier 'meta
           x-select-enable-clipboard t)
     (exec-path-from-shell-initialize))
   #+END_SRC

   Some mac-bindings interfere with Emacs bindings.

   #+BEGIN_SRC emacs-lisp
   (when (boundp 'mac-pass-command-to-system)
      (setq mac-pass-command-to-system nil))
   #+END_SRC   

** Packages

   Managing extensions and downloading packages for Emacs is simplified using =package= 
   which is built in to Emacs 24 and newer. To load downloaded packages we need to
   initialize =package=. =cl= is a library that contains many functions from
   Common Lisp, and comes in handy quite often, so we want to make sure it's loaded, 
   along with =package=, which is obviously needed.

   Packages can be fetched from different mirrors, [[http://melpa.milkbox.net/#/][melpa]] is the largest
   archive and is well maintained. Install =use-package= in order to require
   packages and manage hooks and binds in a modular way.

   #+BEGIN_SRC emacs-lisp
   (require 'cl)
   (require 'package)
   (setq package-archives
         '(("marmalade" . "https://marmalade-repo.org/packages/")
           ("gnu" . "https://elpa.gnu.org/packages/")
           ("org" . "http://orgmode.org/elpa/")
           ("melpa" . "https://melpa.org/packages/")
           ("melpa-stable" . "https://stable.melpa.org/packages/")))
   (package-initialize)

   (unless (package-installed-p 'use-package)
     (package-refresh-contents)
     (package-install 'use-package))

   (eval-when-compile
     (require 'use-package))
   ; Diminished modes from modeline
   (require 'diminish)
   (require 'bind-key)
   #+END_SRC

   The configuration assumes that the packages listed below are
   installed. To ensure we install missing packages if they are missing.

   #+BEGIN_SRC emacs-lisp
         ; We can control the amount of output use-package generates by setting
         ; use-package-verbose to true
         (setq use-package-verbose t)

         ; Quickly switch windows in Emacs
         (use-package ace-window
           :ensure t
           :defer 2
           :bind (("C-x o" . ace-window))
           :config (setq aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l)))

         ; Keeps your code always indented, reindenting after every change. Multiple
         ; languages supported.
         (use-package aggressive-indent
           :ensure t
           :defer 2
           :config (global-aggressive-indent-mode 1))

         ; Automatically compile Emacs Lisp libraries
         (use-package auto-compile
           :ensure t
           :defer 2
           :defer t)

         ; Does asynchronous processing in Emacs
         (use-package async
           :ensure t
           :defer 2
           :defer t)

         ; Jump to things in Emacs tree-style
         (use-package avy
           :ensure t
           :bind (("C-'" . avy-goto-char)
                  ("C-:" . avy-goto-char-2)))

         ; If you have lots of keybindings set in your .emacs file, it can be hard
         ; to know which ones you haven't set yet, and which may now be overriding
         ; some new default in a new emacs version. This module aims to solve that
         ; problem.
         (use-package bind-key
           :ensure t)

         ; Clojure Interactive Development Environment
         (use-package cider
           :ensure t
           :defer 5
           :pin melpa-stable
           :init
           (add-hook 'cider-mode-hook #'clj-refactor-mode)
           :config
           ; Enable eldoc in Clojure (Cider) buffers
           (add-hook 'cider-mode-hook #'eldoc-mode)
           ; The use of paredit when editing Clojure (or any other Lisp) code is
           ; highly recommended. You're probably using it already in your
           ; clojure-mode buffers (if you're not you probably should). You might
           ; also want to enable paredit in the REPL buffer as well.
           (add-hook 'cider-repl-mode-hook #'paredit-mode)
           (setq
             ; Controls whether to pop to the REPL buffer on connect.
             cider-repl-pop-to-buffer-on-connect nil
             ; Useful for debugging
             nrepl-log-messages t
             ; Switch to REPL in this window
             cider-repl-display-in-current-window t 
             ; Syntax highlighting in REPL   
             cider-repl-use-clojure-font-lock t
             ; always save when loading buffer
             cider-prompt-save-file-on-load 'always-save 
             ; Syntax highlight all namespaces                
             cider-font-lock-dynamically '(macro core function var) 
             ; Hide *nrepl-connection* and *nrepl-server* buffers from appearing
             ; in some buffer switching commands like switch-to-buffer
             nrepl-hide-special-buffers t
             ; Syntax highlight evaluation overlays
             cider-overlays-use-font-lock t)
           ; REPL always pretty-prints results
           (cider-repl-toggle-pretty-printing))

         ; Adds powerful refactoring facilities to Cider
         (use-package clj-refactor
           :ensure t
           :defer 5
           :diminish clj-refactor-mode
           :config (cljr-add-keybindings-with-prefix "C-c C-m"))

         ; Provides Emacs font-lock, indentation, navigation and refactoring.
         (use-package clojure-mode
           :ensure t
           :init (add-hook 'clojure-mode-hook #'aggressive-indent-mode)
                 (add-hook 'clojure-mode-hook #'clj-refactor-mode)
                 (add-hook 'clojure-mode-hook #'paredit-mode)
                 (add-hook 'clojure-mode-hook #'yas-minor-mode)         
                 (add-hook 'clojure-mode-hook #'linum-mode)             
                 (add-hook 'clojure-mode-hook #'subword-mode)
                 (add-hook 'clojure-mode-hook #'rainbow-delimiters-mode)
                 (add-hook 'clojure-mode-hook #'eldoc-mode))

         ; [[https://github.com/auto-complete/auto-complete][Auto-Complete]] has been a part of my config for years, but I want to try
         ; out [[http://company-mode.github.io/][company-mode]]. If I code in an environment with good completion, I've
         ; made an habit of trying to /guess/ function-names, and looking at the
         ; completions for the right one. 
         (use-package company
           :ensure t
           :defer 5
           :bind (("C-d" . company-show-doc-buffer)
                  ("C-n" . company-select-next)
                  ("C-p" . company-select-previous)
                  ("C-TAB" . company-complete))
           :init (add-hook 'after-init-hook #'global-company-mode)
           :config (setq company-idle-delay 0
                         company-echo-delay 0
                         company-dabbrev-downcase nil
                         company-minimum-prefix-length 3
                         company-selection-wrap-around t
                         company-transformers '(company-sort-by-occurrence
                                                company-sort-by-backend-importance)))

         ; Remove the old keybinding. This keybinding will be used to work with
         ; common text functions.
         (global-set-key (kbd "C-t") nil)

         ; Display the definition of word at point
         (use-package define-word
           :ensure t
           :defer 2
           :bind (("C-t d" . define-word-at-point)
                  ("C-t D" . define-word)))

         ; This package allows to translate the strings using Google Translate
         ; service directly from GNU Emacs.
         (use-package google-translate
           :ensure t
           :defer 5
           :bind (("C-t t" . google-translate-smooth-translate))
           :config (setq google-translate-translation-directions-alist
                         '(("en" . "pt") ("pt" . "en") (nil . nil))))


         ; Extends functionalities provided by standard GNU Emacs libraries dired.el,
         ; dired-aux.el, and dired-x.el.
         (use-package dired+
           :ensure t
           :defer 0.1)

         ; A emacs tree plugin like NerdTree for Vim.
         (use-package neotree
           :ensure t
           :pin melpa-stable
           :defer 5
           :config (global-set-key [f8] 'neotree-toggle))

         ; Directory tree comparison mode for Emacs
         (use-package ztree
           :ensure t
           :defer 5)

         ; Increase selected region by semantic units
         (use-package expand-region
           :ensure t
           :pin melpa-stable
           :bind (("C->" . er/expand-region)
                  ("C-<" . er/contract-region))
           :init (setq expand-region-smart-cursor nil))

         ; Flyspell highlights incorrect words as soon as they are completed or as
         ; soon as the TextCursor hits a new word.
         (use-package flyspell
           :ensure t
           :init (progn
                   (add-hook 'prog-mode-hook 'flyspell-prog-mode)
                   (add-hook 'text-mode-hook 'flyspell-mode))
           :config (use-package flyspell-correct
                     :ensure t
                     :defer t
                     :pin melpa
                     :bind (:map flyspell-mode-map
                                 ("C-;" . flyspell-correct-previous-word-generic))
                     :config (setq flyspell-correct-interface 'flyspell-correct-ivy)))

         (defun flyspell-correct-ivy (candidates word)
           "Run `ivy-read' for the given CANDIDATES given by flyspell for the
           WORD. Return a selected word to use as a replacement."
           (let* (result
                  (action-default (lambda (x) (setq result x)))
                  (action-save-word (lambda (_) (setq result (cons 'save word))))
                  (action-accept-session (lambda (_) (setq result (cons 'session word))))
                  (action-accept-buffer (lambda (_) (setq result (cons 'buffer word))))
                  (action `(1
                            ("o" ,action-default "correct")
                            ("s" ,action-save-word "Save")
                            ("S" ,action-accept-session "Accept (session)")
                            ("b" ,action-accept-buffer "Accept (buffer)"))))
             (ivy-read (format "Suggestions for \"%s\" in dictionary \"%s\": "
                               word (or ispell-local-dictionary
                                        ispell-dictionary
                                        "Default"))
                       candidates
                       :action action
                       :caller 'flyspell-correct-ivy)
             result))

         ; 
         ;(use-package flyspell-correct
         ;  :ensure t
         ;  :defer t
         ;  :pin melpa
         ;  :bind (:map flyspell-mode-map
         ;              ("C-;" . flyspell-correct-previous-word-generic))
         ;  :config (setq flyspell-correct-interface 'flyspell-correct-ivy))

         ; GNU Emacs and Scheme talk to each other
         (use-package geiser 
           :ensure t
           :defer t)

         ; Fringe version of git-gutter.el
         (use-package git-gutter-fringe
           :ensure t
           :diminish git-gutter-mode
           :defer 3
           :init (add-hook 'git-gutter:update-hooks 'magit-after-revert-hook)
                 (add-hook 'git-gutter:update-hooks 'magit-not-reverted-hook)
           :config (use-package git-gutter
                     :ensure t)
                   (global-git-gutter-mode t)
                   (setq git-gutter:update-interval 1)
                   (setq-default left-fringe-width  20
                                 right-fringe-width 20)
                   (fringe-helper-define 'git-gutter-fr:added nil
                     "...XX..."
                     "...XX..."
                     "...XX..."
                     "XXXXXXXX"
                     "XXXXXXXX"
                     "...XX..."
                     "...XX..."
                     "...XX...")

                   (fringe-helper-define 'git-gutter-fr:deleted nil
                     "........"
                     "........"
                     "........"
                     "XXXXXXXX"
                     "XXXXXXXX"
                     "........"
                     "........"
                     "........")

                   (fringe-helper-define 'git-gutter-fr:modified nil
                     "........"
                     "X......X"
                     "XX....XX"
                     "XXX..XXX"
                     "XXXXXXXX"
                     "XX.XX.XX"
                     "XX....XX"
                     "........"))

         ; Automatic resizing windows to golden ratio
         (use-package golden-ratio
           :ensure t
           :diminish golden-ratio-mode
           :init (golden-ratio-mode 1)
                 (add-to-list 'golden-ratio-extra-commands 'ace-window)
           :defer 2)

         ; This is a package for GNU Emacs that can be used to tie related commands
         ; into a family of short bindings with a common prefix
         (use-package hydra
           :ensure t
           :defer 2
           :bind (("s-f" . hydra-projectile/body)
                  ("C-x t" . hydra-toggle/body)
                  ("C-M-o" . hydra-window/body))
           :config (hydra-add-font-lock)

                   (use-package windmove
                      :ensure t)

                   (defhydra hydra-error (global-map "M-g")
                     "goto-error"
                     ("h" flycheck-list-errors "first")
                     ("j" flycheck-next-error "next")
                     ("k" flycheck-previous-error "prev")
                     ("v" recenter-top-bottom "recenter")
                     ("q" nil "quit"))

                   (defhydra hydra-global-org (:color blue
                                               :hint nil)
   "
   Timer^^        ^Clock^         ^Capture^
   --------------------------------------------------
   s_t_art        _w_ clock in    _c_apture
    _s_top        _o_ clock out   _l_ast capture
   _r_eset        _j_ clock goto
   _p_rint
   "
                     ("t" org-timer-start)
                     ("s" org-timer-stop)
                     ;; Need to be at timer
                     ("r" org-timer-set-timer)
                     ;; Print timer value to buffer
                     ("p" org-timer)
                     ("w" (org-clock-in '(4)))
                     ("o" org-clock-out)
                     ;; Visit the clocked task from any buffer
                     ("j" org-clock-goto)
                     ("c" org-capture)
                     ("l" org-capture-goto-last-stored))

                     (global-set-key [f11] 'hydra-global-org/body))

         ; Awesome interface for nearly everything
         (use-package ivy
           :ensure t
           :diminish ivy-mode
           :init (ivy-mode 1)
           :bind (("C-x b" . ivy-switch-buffer)
                  ("C-c C-r" . ivy-resume))
           :config (progn
                     (setq ivy-use-virtual-buffers t)
                     (setq ivy-extra-directories nil)
                     (setq ivy-re-builders-alist
                       ;; allow input not in order
                       '((t . ivy--regex-ignore-order)))))

         (use-package swiper
           :ensure t
           :bind (("M-o" . swiper)))

         ; A collection of Ivy-enhanced versions of common Emacs commands
         (use-package counsel
           :ensure t
           :bind (("C-c h" . counsel-descbinds)
                  ("M-x" . counsel-M-x)
                  ("M-y" . counsel-yank-pop)
                  ; Silver searcher must be installed in order to Counsel-ag work
                  ; properly. See [[https://github.com/ggreer/the_silver_searcher][Silver Searcher]].
                  ("M-p" . counsel-ag)
                  ("C-c l" . counsel-locate)
                  ("C-x C-f" . counsel-find-file)))

         ; Python auto-completion for Emacs
         (use-package jedi
           :ensure t
           :defer 5)

         (use-package js2-refactor
           :ensure t
           :defer t
           :config (use-package js2-mode
                     :ensure t
                     :defer 3))

         ; Control Git from Emacs. In order to use =magit= one should have git version >=
         ; 1.94 installed
         (use-package magit
           :ensure t
           :defer 5
           :bind ("C-x g" . magit-status))

         ; Emacs Major mode for Markdown-formatted files
         (use-package markdown-mode
           :ensure t
           :defer 5)

         ; Port of the popular TextMate theme by Wimer Hazenberg
         (use-package monokai-theme
           :ensure t
           :defer t)

         ; Multiple cursors for Emacs
         (use-package multiple-cursors
           :ensure t
           :bind (("C-c e" . mc/edit-lines)
                  ("C-c a" . mc/mark-all-like-this)
                  ("C-c n" . mc/mark-next-like-this)))

         ; Outline-based notes management and organizer. All contrib files are also
         ; installed
         (use-package org
           :ensure org-plus-contrib
           :pin org
           :defer 1)

         ; Port of the popular TextMate theme Monokai by Wimer Hazenberg
         (use-package monokai-theme
           :ensure t)

         ;; Install paredit and enable it in elisp and Clojure(script) modes
         (use-package paredit
           :ensure t
           :defer 1
           :init (dolist (mode '(scheme emacs-lisp lisp clojure clojurescript js2))
                  (add-hook (intern (concat (symbol-name mode) "-mode-hook"))
                            'paredit-mode)))

         ; The library uniquify overrides Emacs' default mechanism for making buffer names unique
         ; (using suffixes like <2>, <3> etc.) with a more sensible behaviour which use
         ; parts of the file names to make the buffer names distinguishable.
         (use-package uniquify
          :ensure nil
          :config (setq uniquify-buffer-name-style 'reverse)
                  (setq uniquify-separator "|")
                  (setq uniquify-after-kill-buffer-p t)
                  (setq uniquify-ignore-buffers-re "^*"))

         ; Emacs support library for PDF files
         (use-package pdf-tools
           :ensure t
           :defer 5)

         ; Manage and navigate projects in Emacs easily
         (use-package projectile
           :ensure t
           :defer 2)

         ; Counsel-projectile provides further ivy integration into projectile by
         ; taking advantage of ivy's mechanism to select from a list of actions
         ; and/or apply an action without leaving the completion session.
         (use-package counsel-projectile
           :ensure t
           :defer 2
           :config (counsel-projectile-on))

         ; Highlights delimiters such as parentheses, brackets or braces according to
         ; their depth
         (use-package rainbow-delimiters
           :ensure t
           :init (add-hook 'prog-mode-hook #'rainbow-delimiters-mode))

         ; Slamhound rips Clojure ns form apart and reconstructs it.
         (use-package slamhound
           :ensure t
           :defer t
           :commands (slamhound))

         ; Superior Lisp Interaction Mode for Emacs
         (use-package slime
           :ensure t
           :defer 2)

         ; We want to navigate camelCase words as separate words.
         (use-package subword
           :diminish subword-mode
           :init (global-subword-mode)
           :defer 5)

         ; Try out Emacs packages without installation
         (use-package try
           :ensure t
           :defer t)

         ; Treats undo history as a branching tree of changes, similar to the way Vim handles it.
         (use-package undo-tree
           :ensure t
           :defer 0.1
           :diminish undo-tree-mode
           :init (global-undo-tree-mode))

         ; Emacs package that displays available keybindings in popup
         (use-package which-key
           :ensure t
           :defer 0.1
           :pin "melpa-stable"
           :init (which-key-mode))

         ; Whitespace-cleanup-mode is a minor mode which calls whitespace-cleanup
         ; before saving the current buffer, but only if the whitespace in the buffer
         ; was initially clean. It determines this by quickly checking to see if
         ; whitespace-cleanup would have any effect on the buffer.
         (use-package whitespace-cleanup-mode
           :ensure t
           :init
           (global-whitespace-cleanup-mode t))


         (use-package yasnippet
           :ensure t
           :defer 5
           :init (yas-global-mode 1)
           :config ; Modern API for working with files and directories in Emacs
                   (use-package f
                     :ensure t)
                   (let ((snippets-dir (expand-file-name "snippets" user-emacs-directory)))
                     (if (f-directory? snippets-dir)
                       (setq yas-snippet-dirs snippets-dir)))) 

         ; An awsome low contrast theme          
         (use-package zenburn-theme
           :ensure t)

         ;; This package is only relevant for Mac OS X.
         (when (memq window-system '(ns))
           (use-package exec-path-from-shell
             :ensure t
             :init (exec-path-from-shell-initialize)))
   #+END_SRC

** Visual

   Change the color-theme to =zenburn=.

   #+BEGIN_SRC emacs-lisp
   (load-theme 'zenburn t)
   #+END_SRC

   =zenburn= is my preferred low contrast theme, but =monokai= makes a good
   default dark theme. I want to be able to cycle between these.

   #+BEGIN_SRC emacs-lisp
   (defun cycle-themes ()
     "Returns a function that lets you cycle your themes."
     (lexical-let ((themes '#1=(zenburn monokai . #1#)))
       (lambda ()
         (interactive)
         ;; Rotates the thme cycle and changes the current theme.
         (load-theme (car (setq themes (cdr themes))) t))))
   #+END_SRC

   Use the [[http://www.levien.com/type/myfonts/inconsolata.html][Inconsolata]] font if it's installed on the system.

   #+BEGIN_SRC emacs-lisp
   (cond ((member "Source Code Pro" (font-family-list))
          (set-face-attribute 'default nil :font "Source Code Pro-13"))
         ((member "Inconsolata" (font-family-list))
          (set-face-attribute 'default nil :font "Inconsolata-14")))
   #+END_SRC

   New in Emacs 24.4 is the =prettify-symbols-mode=! It's neat.

   #+BEGIN_SRC emacs-lisp
   (setq-default prettify-symbols-alist '(("lambda" . ?λ)
                                          ("delta" . ?Δ)
                                          ("gamma" . ?Γ)
                                          ("phi" . ?φ)
                                          ("psi" . ?ψ)))
   #+END_SRC

** PDF Tools

   [[https://github.com/politza/pdf-tools][PDF Tools]] makes a huge improvement on the built-in [[http://www.gnu.org/software/emacs/manual/html_node/emacs/Document-View.html][doc-view-mode]]; the only
   drawback is the =pdf-tools-install= (which has to be executed before the
   package can be used) takes a couple of /seconds/ to execute. Instead of
   running it at init-time, we'll run it whenever a PDF is opened. Note that
   it's only slow on the first run! Another important thing to note is that
   =glib= and =poppler= libs must be present in order to correctly compile
   =pdf-tools=. For example, using /brew install glib poppler/ in OSX shoud be
   enough (this gonna take a looong time).

   #+BEGIN_SRC emacs-lisp
   (add-hook 'pdf-tools-enabled-hook 'auto-revert-mode)
   (add-to-list 'auto-mode-alist '("\\.pdf\\'" . pdf-tools-install))
   #+END_SRC

** Calendar

   Define a function to display week numbers in =calender-mode=. The snippet
   is from [[http://www.emacswiki.org/emacs/CalendarWeekNumbers][EmacsWiki]].

   #+BEGIN_SRC emacs-lisp
   (defun calendar-show-week (arg)
     "Displaying week number in calendar-mode."
     (interactive "P")
     (copy-face font-lock-constant-face 'calendar-iso-week-face)
     (set-face-attribute
      'calendar-iso-week-face nil :height 0.7)
     (setq calendar-intermonth-text
           (and arg
                '(propertize
                  (format
                   "%2d"
                   (car (calendar-iso-from-absolute
                         (calendar-absolute-from-gregorian
                          (list month day year)))))
                  'font-lock-face 'calendar-iso-week-face))))
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
   (setq calendar-latitude -22.9083
         calendar-longitude -43.1971
         calendar-location-name "Rio de Janeiro, Brasil")
   #+END_SRC

** Email

GPG must be installed in order to gnus work properly. On MAC, =brew install gpg=
should suffice to install all dependencies.
   
#+BEGIN_SRC emacs-lisp 
(setq user-mail-address "anderson.freitass@gmail.com"
      user-full-name "Anderson Freitas")

(setq gnus-select-method
      '(nnimap "gmail"
               (nnimap-address "imap.gmail.com")  
               (nnimap-server-port 993)
               (nnimap-stream ssl)))

(setq message-send-mail-function 'smtpmail-send-it
      smtpmail-starttls-credentials '(("smtp.gmail.com" 587 nil nil))
      smtpmail-auth-credentials '(("smtp.gmail.com" 587 "anderson.freitass@gmail.com" nil))
      smtpmail-default-smtp-server "smtp.gmail.com"
      smtpmail-smtp-server "smtp.gmail.com"
      smtpmail-stream-type 'starttls
      smtpmail-smtp-service 587)
#+END_SRC   

** Flyspell

   Flyspell offers on-the-fly spell checking. We can enable flyspell for all
   text-modes with this snippet.

   #+BEGIN_SRC emacs-lisp
   (add-hook 'text-mode-hook 'turn-on-flyspell)
   #+END_SRC

   To use flyspell for programming there is =flyspell-prog-mode=, that only
   enables spell checking for comments and strings. We can enable it for all
   programming modes using the =prog-mode-hook=.

   #+BEGIN_SRC emacs-lisp
   (add-hook 'prog-mode-hook 'flyspell-prog-mode)
   #+END_SRC

   When working with several languages, we should be able to cycle through
   the languages we most frequently use. Every buffer should have a separate
   cycle of languages, so that cycling in one buffer does not change the
   state in a different buffer (this problem occurs if you only have one
   global cycle). We can implement this by using a [[http://www.gnu.org/software/emacs/manual/html_node/elisp/Closures.html][closure]].

   #+BEGIN_SRC emacs-lisp
   (defun cycle-languages ()
     "Changes the ispell dictionary to the first element in
   ISPELL-LANGUAGES, and returns an interactive function that cycles
   the languages in ISPELL-LANGUAGES when invoked."
     (lexical-let ((ispell-languages '#1=("en_US" "pt_BR" . #1#)))
       (ispell-change-dictionary (car ispell-languages))
       (lambda ()
         (interactive)
         ;; Rotates the languages cycle and changes the ispell dictionary.
         (ispell-change-dictionary
          (car (setq ispell-languages (cdr ispell-languages)))))))
   #+END_SRC

   =flyspell= signals an error if there is no spell-checking tool is
   installed. We can advice =turn-on-flyspell= and =flyspell-prog-mode= to
   only try to enable =flyspell= if a spell-checking tool is available. Also
   we want to enable cycling the languages by typing =C-c l=, so we bind the
   function returned from =cycle-languages=.

   #+BEGIN_SRC emacs-lisp
   (defadvice turn-on-flyspell (before check nil activate)
     "Turns on flyspell only if a spell-checking tool is installed."
     (when (executable-find ispell-program-name)
       (local-set-key (kbd "C-c l") (cycle-languages))))
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
   (defadvice flyspell-prog-mode (before check nil activate)
     "Turns on flyspell only if a spell-checking tool is installed."
     (when (executable-find ispell-program-name)
       (local-set-key (kbd "C-c l") (cycle-languages))))
   #+END_SRC

** Org

   I use =org-agenda= along with =org-capture= for appointments and such.

   #+BEGIN_SRC emacs-lisp
   (setq org-agenda-files '("~/Dropbox/agenda.org")  ; A list of agenda files
         org-agenda-default-appointment-duration 120 ; 2 hours appointments
         org-capture-templates                       ; Template for adding tasks
         '(("t" "Oppgave" entry (file+headline "~/Dropbox/agenda.org" "Oppgaver")
            "** TODO %?" :prepend t)
           ("m" "Master" entry (file+olp "~/Dropbox/agenda.org" "Oppgaver" "Master")
            "*** TODO %?" :prepend t)
           ("a" "Avtale" entry (file+headline "~/Dropbox/agenda.org" "Avtaler")
            "** %?\n   SCHEDULED: %T" :prepend t)))
   #+END_SRC

   When editing org-files with source-blocks, we want the source blocks to
   be themed as they would in their native mode.

   #+BEGIN_SRC emacs-lisp
   (setq org-src-fontify-natively t
         org-src-tab-acts-natively t
         org-confirm-babel-evaluate nil
         org-edit-src-content-indentation 0)
   #+END_SRC

   This is quite an ugly fix for allowing code markup for expressions like
   ="this string"=, because the quotation marks causes problems.

   #+BEGIN_SRC emacs-lisp
   (eval-after-load "org"
     '(progn
        (setcar (nthcdr 2 org-emphasis-regexp-components) " \t\n,")
        (custom-set-variables `(org-emphasis-alist ',org-emphasis-alist))))
   #+END_SRC

** Interactive functions
   <<sec:defuns>>

   =just-one-space= removes all whitespace around a point - giving it a
   negative argument it removes newlines as well. We wrap a interactive
   function around it to be able to bind it to a key. In Emacs 24.4
   =cycle-spacing= was introduced, and it works like =just-one-space=, but
   when run in succession it cycles between one, zero and the original
   number of spaces.

   #+BEGIN_SRC emacs-lisp
   (defun cycle-spacing-delete-newlines ()
     "Removes whitespace before and after the point."
     (interactive)
     (if (version< emacs-version "24.4")
         (just-one-space -1)
       (cycle-spacing -1)))
   #+END_SRC

   Often I want to find other occurrences of a word I'm at, or more
   specifically the symbol (or tag) I'm at. The
   =isearch-forward-symbol-at-point= in Emacs 24.4 works well for this, but
   I don't want to be bothered with the =isearch= interface. Rather jump
   quickly between occurrences of a symbol, or if non is found, don't do
   anything.

   #+BEGIN_SRC emacs-lisp
   (defun jump-to-symbol-internal (&optional backwardp)
     "Jumps to the next symbol near the point if such a symbol
   exists. If BACKWARDP is non-nil it jumps backward."
     (let* ((point (point))
            (bounds (find-tag-default-bounds))
            (beg (car bounds)) (end (cdr bounds))
            (str (isearch-symbol-regexp (find-tag-default)))
            (search (if backwardp 'search-backward-regexp
                      'search-forward-regexp)))
       (goto-char (if backwardp beg end))
       (funcall search str nil t)
       (cond ((<= beg (point) end) (goto-char point))
             (backwardp (forward-char (- point beg)))
             (t  (backward-char (- end point))))))

   (defun jump-to-previous-like-this ()
     "Jumps to the previous occurrence of the symbol at point."
     (interactive)
     (jump-to-symbol-internal t))

   (defun jump-to-next-like-this ()
     "Jumps to the next occurrence of the symbol at point."
     (interactive)
     (jump-to-symbol-internal))
   #+END_SRC

   To duplicate either selected text or a line we define this interactive
   function.

   #+BEGIN_SRC emacs-lisp
   (defun duplicate-thing (comment)
     "Duplicates the current line, or the region if active. If an argument is
   given, the duplicated region will be commented out."
     (interactive "P")
     (save-excursion
       (let ((start (if (region-active-p) (region-beginning) (point-at-bol)))
             (end   (if (region-active-p) (region-end) (point-at-eol))))
         (goto-char end)
         (unless (region-active-p)
           (newline))
         (insert (buffer-substring start end))
         (when comment (comment-region start end)))))
   #+END_SRC

   To tidy up a buffer we define this function borrowed from [[https://github.com/simenheg][simenheg]].

   #+BEGIN_SRC emacs-lisp
   (defun tidy ()
     "Ident, untabify and unwhitespacify current buffer, or region if active."
     (interactive)
     (let ((beg (if (region-active-p) (region-beginning) (point-min)))
           (end (if (region-active-p) (region-end) (point-max))))
       (indent-region beg end)
       (whitespace-cleanup)
       (untabify beg (if (< end (point-max)) end (point-max)))))
   #+END_SRC

   Org mode does currently not support synctex (which enables you to jump from
   a point in your TeX-file to the corresponding point in the pdf), and it
   [[http://comments.gmane.org/gmane.emacs.orgmode/69454][seems like a tricky problem]].

   Calling this function from an org-buffer jumps to the corresponding section
   in the exported pdf (given that the pdf-file exists), using pdf-tools.

   #+BEGIN_SRC emacs-lisp
   (defun org-sync-pdf ()
     (interactive)
     (let ((headline (nth 4 (org-heading-components)))
           (pdf (concat (file-name-base (buffer-name)) ".pdf")))
       (when (file-exists-p pdf)
         (find-file-other-window pdf)
         (pdf-links-action-perform
          (cl-find headline (pdf-info-outline pdf)
                   :key (lambda (alist) (cdr (assoc 'title alist)))
                   :test 'string-equal)))))
   #+END_SRC

** Advice

   An advice can be given to a function to make it behave differently. This
   advice makes =eval-last-sexp= (bound to =C-x C-e=) replace the sexp with
   the value.

   #+BEGIN_SRC emacs-lisp
   (defadvice eval-last-sexp (around replace-sexp (arg) activate)
     "Replace sexp when called with a prefix argument."
     (if arg
         (let ((pos (point)))
           ad-do-it
           (goto-char pos)
           (backward-kill-sexp)
           (forward-sexp))
       ad-do-it))
   #+END_SRC

   When interactively changing the theme (using =M-x load-theme=), the
   current custom theme is not disabled. This often gives weird-looking
   results; we can advice =load-theme= to always disable themes currently
   enabled themes.

   #+BEGIN_SRC emacs-lisp
   (defadvice load-theme
       (before disable-before-load (theme &optional no-confirm no-enable) activate)
     (mapc 'disable-theme custom-enabled-themes))
   #+END_SRC

** global-scale-mode

   These functions provide something close to ~text-scale-mode~, but for every
   buffer, including the minibuffer and mode line.

   #+BEGIN_SRC emacs-lisp
   (lexical-let* ((default (face-attribute 'default :height))
                  (size default))

     (defun global-scale-default ()
       (interactive)
       (setq size default)
       (global-scale-internal size))

     (defun global-scale-up ()
       (interactive)
       (global-scale-internal (incf size 20)))

     (defun global-scale-down ()
       (interactive)
       (global-scale-internal (decf size 20)))

     (defun global-scale-internal (arg)
       (set-face-attribute 'default (selected-frame) :height arg)
       (set-temporary-overlay-map
        (let ((map (make-sparse-keymap)))
          (define-key map (kbd "C-=") 'global-scale-up)
          (define-key map (kbd "C-+") 'global-scale-up)
          (define-key map (kbd "C--") 'global-scale-down)
          (define-key map (kbd "C-0") 'global-scale-default) map))))
   #+END_SRC

* Mode specific
** Shell

   I use =shell= whenever i want to use access the command line in Emacs. I
   keep a symlink between my =~/.bash_profile= (because I run OS X) and
   =~/.emacs_bash=, to make the transition between my standard terminal and
   the shell as small as possible. To be able to quickly switch back and
   forth between a shell I make use of this little function.

   #+BEGIN_SRC emacs-lisp
   (defun toggle-shell ()
     "Jumps to eshell or back."
     (interactive)
     (if (string= (buffer-name) "*shell*")
         (switch-to-prev-buffer)
       (shell)))
   #+END_SRC

   I'd like the =C-l= to work more like the standard terminal (which works
   like running =clear=), and resolve this by simply removing the
   buffer-content. Mind that this is not how =clear= works, it simply adds a
   bunch of newlines, and puts the prompt at the top of the window, so it
   does not remove anything. In Emacs removing stuff is less of a worry,
   since we can always undo!

   #+BEGIN_SRC emacs-lisp
   (defun clear-comint ()
     "Runs `comint-truncate-buffer' with the
   `comint-buffer-maximum-size' set to zero."
     (interactive)
     (let ((comint-buffer-maximum-size 0))
       (comint-truncate-buffer)))
   #+END_SRC

   Lastly we should bind our functions. The =toggle-shell= should be a
   global binding (because we want to be able to switch to a shell from any
   buffer), but the =clear-shell= should only affect =shell-mode=.

   #+BEGIN_SRC emacs-lisp
   (add-hook 'comint-mode-hook (lambda () (local-set-key (kbd "C-l") 'clear-comint)))
   #+END_SRC

** Lisp

   I use =Paredit= when editing lisp code, we enable this for all lisp-modes.

   #+BEGIN_SRC emacs-lisp
   (dolist (mode '(cider-repl-mode
                   clojure-mode
                   ielm-mode
                   geiser-repl-mode
                   slime-repl-mode
                   lisp-mode
                   emacs-lisp-mode
                   lisp-interaction-mode
                   scheme-mode))
     ;; add paredit-mode to all mode-hooks
     (add-hook (intern (concat (symbol-name mode) "-hook")) 'paredit-mode))
   #+END_SRC

*** Emacs Lisp

    In =emacs-lisp-mode= we can enable =eldoc-mode= to display information
    about a function or a variable in the echo area.

    #+BEGIN_SRC emacs-lisp
    (add-hook 'emacs-lisp-mode-hook 'turn-on-eldoc-mode)
    (add-hook 'lisp-interaction-mode-hook 'turn-on-eldoc-mode)
    #+END_SRC

*** Common lisp

    I use [[http://www.common-lisp.net/project/slime/][Slime]] along with =lisp-mode= to edit Common Lisp code. Slime
    provides code evaluation and other great features, a must have for a
    Common Lisp developer. [[http://www.quicklisp.org/beta/][Quicklisp]] is a library manager for Common Lisp,
    and you can install Slime following the instructions from the site along
    with this snippet.

    #+BEGIN_SRC emacs-lisp
    (defun activate-slime-helper ()
      (when (file-exists-p "~/.quicklisp/slime-helper.el")
        (load (expand-file-name "~/.quicklisp/slime-helper.el"))
        (define-key slime-repl-mode-map (kbd "C-l")
          'slime-repl-clear-buffer))
      (remove-hook 'lisp-mode-hook #'activate-slime-helper))

    (add-hook 'lisp-mode-hook #'activate-slime-helper)
    #+END_SRC

    We can specify what Common Lisp program Slime should use (I use SBCL).

    #+BEGIN_SRC emacs-lisp
    (setq inferior-lisp-program "sbcl")
    #+END_SRC

    More sensible =loop= indentation, borrowed from [[https://github.com/simenheg][simenheg]].

    #+BEGIN_SRC emacs-lisp
    (setq lisp-loop-forms-indentation   6
          lisp-simple-loop-indentation  2
          lisp-loop-keyword-indentation 6)
    #+END_SRC

    #+BEGIN_SRC emacs-lisp

    #+END_SRC

*** Scheme

    [[http://www.nongnu.org/geiser/][Geiser]] provides features similar to Slime for Scheme editing. Everything
    works pretty much out of the box, we only need to add auto completion,
    and specify which scheme-interpreter we prefer.

    #+BEGIN_SRC emacs-lisp
    (eval-after-load "geiser"
      '(setq geiser-active-implementations '(guile)))
    #+END_SRC

** LaTeX and org-mode LaTeX export

   =.tex=-files should be associated with =latex-mode= instead of
   =tex-mode=.

   #+BEGIN_SRC emacs-lisp
   (add-to-list 'auto-mode-alist '("\\.tex\\'" . latex-mode))
   #+END_SRC

   Use ~biblatex~ for bibliography.

   #+BEGIN_SRC emacs-lisp
   (setq-default bibtex-dialect 'biblatex)
   #+END_SRC

   I like using the [[https://code.google.com/p/minted/][Minted]] package for source blocks in LaTeX. To make org
   use this we add the following snippet.

   #+BEGIN_SRC emacs-lisp
   (eval-after-load 'org
     '(add-to-list 'org-latex-packages-alist '("" "minted")))
   (setq org-latex-listings 'minted)
   #+END_SRC

   Because [[https://code.google.com/p/minted/][Minted]] uses [[http://pygments.org][Pygments]] (an external process), we must add the
   =-shell-escape= option to the =org-latex-pdf-process= commands. The
   =tex-compile-commands= variable controls the default compile command for
   Tex- and LaTeX-mode, we can add the flag with a rather dirty statement
   (if anyone finds a nicer way to do this, please let me know).

   #+BEGIN_SRC emacs-lisp
   (eval-after-load 'tex-mode
     '(setcar (cdr (cddaar tex-compile-commands)) " -shell-escape "))
   #+END_SRC

   When exporting from Org to LaTeX, use ~latexmk~ for compilation.

   #+BEGIN_SRC emacs-lisp
   (eval-after-load 'ox-latex
     '(setq org-latex-pdf-process
            '("latexmk -pdflatex='pdflatex -shell-escape -interaction nonstopmode' -pdf -f %f")))
   #+END_SRC

   For my thesis, I need to use our university's LaTeX class, this snippet
   makes that class available.

   #+BEGIN_SRC emacs-lisp
   (eval-after-load "ox-latex"
     '(progn
        (add-to-list 'org-latex-classes
                     '("ifimaster"
                       "\\documentclass{ifimaster}
   [DEFAULT-PACKAGES]
   [PACKAGES]
   [EXTRA]
   \\usepackage{babel,csquotes,ifimasterforside,url,varioref}"
                      ("\\chapter{%s}" . "\\chapter*{%s}")
                      ("\\section{%s}" . "\\section*{%s}")
                      ("\\subsection{%s}" . "\\subsection*{%s}")
                      ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                      ("\\paragraph{%s}" . "\\paragraph*{%s}")
                      ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))
       (custom-set-variables '(org-export-allow-bind-keywords t))))
   #+END_SRC

* Key bindings

  Inspired by [[http://stackoverflow.com/questions/683425/globally-override-key-binding-in-emacs][this StackOverflow post]] I keep a =custom-bindings-map= that
  holds all my custom bindings. This map can be activated by toggling a
  simple =minor-mode= that does nothing more than activating the map. This
  inhibits other =major-modes= to override these bindings. I keep this at
  the end of the init-file to make sure that all functions are actually
  defined.

  #+BEGIN_SRC emacs-lisp
  (defvar custom-bindings-map (make-keymap)
    "A keymap for custom bindings.")
  #+END_SRC


** Bindings for built-ins

  #+BEGIN_SRC emacs-lisp
  (define-key custom-bindings-map (kbd "M-u")         'upcase-dwim)
  (define-key custom-bindings-map (kbd "M-c")         'capitalize-dwim)
  (define-key custom-bindings-map (kbd "M-l")         'downcase-dwim)
  (define-key custom-bindings-map (kbd "M-]")         'other-frame)
  (define-key custom-bindings-map (kbd "C-j")         'newline-and-indent)
  (define-key custom-bindings-map (kbd "C-c s")       'ispell-word)
  (define-key custom-bindings-map (kbd "C-c c")       'org-capture)
  (define-key custom-bindings-map (kbd "C-c <up>")    'windmove-up)
  (define-key custom-bindings-map (kbd "C-c <down>")  'windmove-down)
  (define-key custom-bindings-map (kbd "C-c <left>")  'windmove-left)
  (define-key custom-bindings-map (kbd "C-c <right>") 'windmove-right)
  (define-key custom-bindings-map (kbd "C-c t")
    (lambda () (interactive) (org-agenda nil "n")))
  #+END_SRC

** Bindings for functions defined [[sec:defuns][above]]

  #+BEGIN_SRC emacs-lisp
  ; (define-key global-map          (kbd "M-p")     'jump-to-previous-like-this)
  (define-key global-map          (kbd "M-n")     'jump-to-next-like-this)
  (define-key custom-bindings-map (kbd "M-,")     'jump-to-previous-like-this)
  (define-key custom-bindings-map (kbd "M-.")     'jump-to-next-like-this)
  (define-key custom-bindings-map (kbd "C-c .")   (cycle-themes))
  (define-key custom-bindings-map (kbd "C-c C-0") 'global-scale-default)
  (define-key custom-bindings-map (kbd "C-c C-=") 'global-scale-up)
  (define-key custom-bindings-map (kbd "C-c C-+") 'global-scale-up)
  (define-key custom-bindings-map (kbd "C-c C--") 'global-scale-down)
  (define-key custom-bindings-map (kbd "C-x t")   'toggle-shell)
  (define-key custom-bindings-map (kbd "C-c j")   'cycle-spacing-delete-newlines)
  (define-key custom-bindings-map (kbd "C-c d")   'duplicate-thing)
  (define-key custom-bindings-map (kbd "<C-tab>") 'tidy)
  (with-eval-after-load 'org
    (define-key org-mode-map (kbd "C-'") 'org-sync-pdf))
  #+END_SRC

  Lastly we need to activate the map by creating and activating the
  =minor-mode=.

  #+BEGIN_SRC emacs-lisp
  (define-minor-mode custom-bindings-mode
    "A mode that activates custom-bindings."
    t nil custom-bindings-map)
  #+END_SR
* License

  My Emacs configurations written in Org mode.

  Copyright (c) 2017 Anderson Freitas

  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.
